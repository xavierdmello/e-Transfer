import { expect, assert } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";
import { keccak256, encodeAbiParameters, parseAbiParameters } from "viem";

function hashEmail(email: string): `0x${string}` {
  return keccak256(encodeAbiParameters(parseAbiParameters("string"), [email]));
}

const MAX_INT = BigInt(2) ** BigInt(256) - BigInt(1);

describe("ETransfer - Copilot Autogenerated Tests", function () {
  async function deployFixture() {
    const mail1 = "dmello_xavier7@hotmail.com";
    const mail2 = "xaviermdmello@gmail.com";
    const hmail1 = hashEmail(mail1);
    const hmail2 = hashEmail(mail2);
    const [account1, account2, account3] = await ethers.getSigners();

    // Deploy
    let token = await ethers.deployContract("Token");
    await token.waitForDeployment();
    let etransfer = await ethers.deployContract("ETransfer", [await token.getAddress()]);
    await etransfer.waitForDeployment();

    // Link Accounts
    await etransfer.linkAccount(hmail1, account1.address);
    await etransfer.linkAccount(hmail2, account2.address);

    // Mint some
    await token.mint(account1.address, 100);
    await token.mint(account2.address, 100);

    // Approve
    await token.connect(account1).approve(await etransfer.getAddress(), MAX_INT);
    await token.connect(account2).approve(await etransfer.getAddress(), MAX_INT);

    return { etransfer, mail1, mail2, hmail1, hmail2, token, account1, account2, account3 };
  }

  it("should fail to send transfer if sender does not have sufficient balance", async function () {
    const { etransfer, account1, hmail2, token } = await loadFixture(deployFixture);

    // Send
    const sendAmount = 1000;
    await expect(etransfer.sendTransfer(hmail2, sendAmount)).to.be.revertedWith("ERC20: transfer amount exceeds balance");

    // Verify balances
    expect(await token.balanceOf(account1.address)).to.equal(100);
    expect(await token.balanceOf(await etransfer.getAddress())).to.equal(0);
  });

  // look more into
  it("should fail to cancel transfer if transfer has already been claimed", async function () {
    let { etransfer, account1, account2, hmail1, hmail2, token } = await loadFixture(deployFixture);

    // Send
    const sendAmount = 10;
    await etransfer.sendTransfer(hmail2, sendAmount);

    // Receive
    etransfer = etransfer.connect(account2);
    await etransfer.receiveTransfer(0, account2.address);

    // Cancel
    etransfer = etransfer.connect(account1);
    await expect(etransfer.cancelTransfer(0)).to.be.reverted;
  });

  it("should return the correct number of pending transfers", async function () {
    const { etransfer, account1, account2, hmail1, hmail2, token } = await loadFixture(deployFixture);

    // Send
    const sendAmount = 10;
    await etransfer.sendTransfer(hmail2, sendAmount);

    // Verify pending transfers
    const pendingTransfers = await etransfer.getPendingTransfers();
    expect(pendingTransfers.length).to.equal(1);
  });

  it("should return the correct information for each pending transfer", async function () {
    const { etransfer, account1, account2, hmail1, hmail2, token } = await loadFixture(deployFixture);

    // Send
    const sendAmount = 10;
    await etransfer.sendTransfer(hmail2, sendAmount);

    // Verify pending transfers
    const pendingTransfers = await etransfer.getPendingTransfers();
    expect(pendingTransfers[0][0]).to.equal(hmail1);
    expect(pendingTransfers[0][1]).to.equal(hmail2);
    expect(pendingTransfers[0][2]).to.equal(account1.address);
    expect(pendingTransfers[0][3]).to.equal(sendAmount);
  });

  it("should return an empty array if there are no pending transfers", async function () {
    const { etransfer } = await loadFixture(deployFixture);

    // Verify pending transfers
    const pendingTransfers = await etransfer.getPendingTransfers();
    expect(pendingTransfers.length).to.equal(0);
  });
});
